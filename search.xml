<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python的基础学习]]></title>
    <url>%2F2019%2F08%2F17%2Fpython%E7%9A%84%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[这是一个终止，又是一个开始 基本用法我决定之后都直接用powershell加上notepad++来实现python 第一个程序先写hellow world 我们命名为ex1.py 如何改到d盘有一个小问题，我们改盘直接d：就可以了之后键入 python ex1.py就可以看到运行了 关于错误要学会看懂错误，以后错误都会归入到这个最初的项目里 最初我写了一个语法错误。 系统会提醒你 1.首先会把行号写出2.会在错的地方下面画一个小三角3.告诉你什么错误(Syntaxerror)语法错误 indexError数据越组，可能是数据过多，可能是是数据组不够。 注释放一个#就可以了 如果要多行注释就每一行放一个井号 数字计算+-*/ 这便是加减乘除 %取余 关于大于小于，会直接返回True False 变量（VARIABLE）python中可以直接用来赋值不用管类型； x = 1要这样写，因为我们可以看的更轻松一点 格式化字符串可以把字符串放到一句话中，但是要用 pd=36 print（f“hellow {pd}”）这个就可以直接把变量放到语句中。 如果出现这种情况， a = &apos;qwe&apos; b = &apos;rty&apos; print(a+b)出现的结果应该是qwerty 关于打印 \n这是随时变行，还有连续三个”””zheshiyijvhua””” 这就可以直接换三行 \这是一个转义字符 /叫做斜杠，，，/叫做反斜杠 转义字符串 字符串连接 a + b‘HelloPython’ 重复输出字符串 a * 2‘HelloHello’[] 通过索引获取字符串中字符a[1]‘e’[ : ] 截取字符串中的一部分a[1:4]‘ell’//就是第一个字符和第四个字符中间的内容in 成员运算符 - 如果字符串中包含给定的字符返回 True“H” in aTruenot in 成员运算符 - 如果字符串中不包含给定的字符返回 True“M” not in aTruer/R 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母”r”（可以大小写）以外，与普通字符串有着几乎完全相同的语法。print r’\n’\nprint R’\n’\n**** input输出测试 print默认是打印一行，结尾加换行。end=’ ‘意思是末尾不换行，加空格 input（）就是录入一个字符串。注意只能录入一个。 input还有一个用法就是 age = input (&quot;How old are you?&quot;) print(f&quot;so,you old is {age}&quot;)这是input的括号中就可以直接写一句提示的话 pydoc有一行代码 PS D:\py&gt; python -m pydoc ex1 hello worldHelp on module ex1: NAME ex1 FILE d:\py\ex1.py 直接会显示其中的内容，名字，和所在目录 pydoc是python自带的一个文档生成工具，使用pydoc可以很方便的查看类和方法结构 类似还有file和os这种对于文件的操作命令。]]></content>
  </entry>
  <entry>
    <title><![CDATA[blog的维护]]></title>
    <url>%2F2019%2F08%2F17%2Fblog%E7%9A%84%E7%BB%B4%E6%8A%A4%2F</url>
    <content type="text"><![CDATA[我blog的笑容由我来守护 19.8.16出现的问题就在昨天我差点失去了我的blog 我的npm打不开,启动npm就显示 npm: command not found所有的hexo命令都是回应 /c/Users/你电脑的用户名/AppData/Roaming/npm/hexo: line 12: node: command not found在网上搜索了类似的问题都是说类似是用户路径上找不到东西,要通过添加环境变量来解决 对,就是环境变量出现了问题 在网上高搜索结果中有向用户路径中添加一个类似NODE_PASH的东西 在路径下录入C:\Users\儿子\nodejs\node_modules 注意 加这个是没用的 ** 真正的解决方法是打开PASH,编辑新建一个.添加 C:\Users\儿子\AppData\Roaming\npm\node_modules 注意是找到node_module这个文件夹的位置.可以直接检索 ** 至于在网上都是添加 C:\Users\儿子\AppData\Roaming\npm\node_modules\hexo\bin这个路径到pash中,我看最高搜索量几个答案都是这样做,也正是因为他们我差点就要重搭blog了.多谢这个兄弟的答案http://https://orzno.com/2018/11/29/Hexo%E5%8D%9A%E5%AE%A2command-not-found%E6%8A%A5%E9%94%99%E7%9A%84%E4%B8%80%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/ 如果一段时间不写blog可能路径就会被自动删除,所以要注意.blog的搭建既然在火车上也没有什么好做的，那么就讲一下blog的搭建 先说一下这些都是凭借记忆来进行，并且我不会插入任何一张图片。 我们是由git和hexo框架构建的blog 首先先进行软件的下载，首先下载git bush（不知道为什么git bush并不能在我电脑上运行，我电脑上直接显示找不到路径，直接运行电脑上内置的MINGW64,由于没什么影响，我就直接用了），以后统称gitt 直接在git官网上就可以进行下载。还有Node.js。这个东西看似没有什么用其实是hexo运行的关键。 之后直接注册git账号，并且建立一个库这个库的名称就是你 github.用户名.io并且还要记得勾选initialize this repository with a README所以一个账号只能支持一个blog的搭建。 之后下载hexo，不需要在什么商店商店上下载， 首先建立一个文件夹。注意要在一个大一点的盘上创立一个文件夹。命名为hexo 之后在git上进入这个地方，（cd /d/blog/hexo/）如果不知道怎么进入那就学习一下简单的cmd操作。在进入后在命令行中键入 npm install hexo-g这是一个npm命令，看不懂没关系，也不重要反正你知道时开始下载hexo就行了之后打开cmd（win+r ）直接就能打开 安装成功后]]></content>
  </entry>
  <entry>
    <title><![CDATA[云加密数据检索系统]]></title>
    <url>%2F2019%2F08%2F12%2F%E4%BA%91%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[这是我做的第一个项目，无论怎样我要好好写 报告书的写作报告书的准备报告书的标题就写成 云加密数据检索系统我要写的部分有 项目摘要（不超过200字） 立项依据（请对项目所涉及到的研究领域现状及问题进行简单介绍） 研究目标与内容（请对拟展开的研究内容及预期要达到的目标进行阐述） 有研究内容 达到的目标可以理解为通过什么技术，能做成什么 1、项目主要研究内容和意义（限300字）在支持隐私保护的几何范围查询问题上，针对密文的索引技术和查询算法是实现用户隐私泄露最小化和检索效率最优达到平衡的关键。针对基于位置服务中面临的大量多维度时空数据，传统的密文存储方式和查询算法不能满足用户快速、准确查询的需求。本方案基于已有的加密算法的安全性理论，结合基于位置服务的多样化实际应用需求，对索引生成算法和查询算法进行深入研究，提高方案的可用性和安全性。2、预期研究目标（限300字） 针对时空数据上几何范围检索上的安全性、可用性需求，提出安全高效的索引生成算法，并设计支持任意几何范围查询的陷门构建方法，形成具有隐私保护的高效、准确几何范围查询方案，解决几何范围查询模式单一、加密方案安全性难以满足用户要求等难题六、项目可行性研究报告提纲（一）立项依据与研究内容1、项目的立项依据：研究意义。随着对基于位置服务（LBS）的需求增加，在基于位置服务的场景下对空间数据进行几何范围搜索也亟需得到进一步探索和利用。一些典型的对于空间数据进行几何范围搜索的场合包括对传感器网络的查询、可计算的地理位置查询等。这类查询都可以将查询内容转换为对应的几何图形，比如长方形、三角形等，最后将落入几何图形中的坐标点信息返回给查询用户。现今最常用的电子地图就利用了这一技术：当用户查询周边指定范围内的特定类目标时，位置服务提供商将用户查询转换为对于地理信息点的圆形区域查询，最后将落入此区域的坐标点的信息返回给用户。在大数据时代背景下，各种移动设备、社交网络以及网页浏览产生的数据量急剧增长，位置服务提供商为了寻求高效准确的解决方案常常选择将大规模的数据外包至公共云服务提供商（例如：谷歌Cloud，亚马逊EC2）。然而，这一选择带来了不可忽视的安全问题。在数据存储和计算外包的情况下，第三方云服务提供商可以接触到所有数据，其中也包含数据拥有者的隐私数据。例如，当数据使用者试图搜索自己所在位置周边的目标点时，其实时位置信息会被云服务提供商获取。由此，防止隐私泄露且支持几何图形查询的方案不仅是亟需得到解决的问题，更是研究热点。针对时空数据的几何范围查询。现有的几何范围查询方案大多无法在实现隐私保护的同时支持高效查询，容易造成用户的隐私数据泄露或查询精度低下。此外，多数方案只支持将查询转化为固定种类图形，无法满足复杂化、个性化的检索需求。 2、项目的研究内容、研究目标以及拟解决的关键科学问题。 2.1研究内容在支持隐私保护的几何范围查询问题上，针对密文的索引技术和查询算法是实现用户隐私泄露最小化和检索效率最优达到平衡的关键。针对基于位置服务中面临的大量多维度时空数据，传统的密文索引生成方式和查询算法不能满足用户快速、准确查询的需求。本方案依据多域安全乘法协议（MSM）[ Liu X, Qin B, Deng R H, et al. A privacy-preserving outsourced functional computation framework across large-scale multiple encrypted domains[J]. IEEE Transactions on Computers, 2016, 65(12): 3567-3579.]、可分布式解密公钥密码系统（PCDD）[ Bresson E, Catalano D, Pointcheval D. A simple public-key cryptosystem with a double trapdoor decryption mechanism and its applications[C]//International Conference on the Theory and Application of Cryptology and Information Security. Springer, Berlin, Heidelberg, 2003: 37-54.]、多项式拟合等技术，基于已有的加密算法的安全性理论，并结合基于位置服务的多样化实际应用需求，从对索引生成算法和查询算法进行深入研究，从而保证时空数据查询的可用性和安全性，并且保证用户查询隐私安全。（一）支持隐私保护的高效几何范围查询方案在对时空数据进行几何范围查询时，在对搜索精度要求尽量接近明文搜索结果、搜索效率要求尽量达到次线性的同时要求隐私泄露控制在泄露函数（Leakage Function）定义以内。而传统常用方案中，早期只支持对特定几何图形的查询[ Wang B, Li M, Wang H, et al. Circular range search on encrypted spatial data[C]//2015 IEEE Conference on Communications and Network Security (CNS). IEEE, 2015: 182-190.]，尽管随后出现了利用布隆过滤器实现多种几何图形查询的方案，但占用存储空间较大且查询效率低。大多现有方案只采用可比较加密（OPE）[ Kerschbaum F. Frequency-hiding order-preserving encryption[C]//Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security. ACM, 2015: 656-667.]等安全性较弱算法，无法达到更高隐私保护要求。因此，本方案针对时空数据检索，首先研究基于多项式拟合的陷门生成方法，满足任意几何范围的查询的需求；进而利用索引生成算法对明文数据进行处理，构建高效的加密时空数据索引结构；最后利用多域安全乘法协议（MSM）及可分布式解密公钥密码系统（PCDD）对相似度进行计算，保证数据拥有方和使用方的隐私安全。2.2研究目标针对时空数据上几何范围检索上的安全性、可用性需求，提出安全高效的索引生成算法，并设计支持任意几何范围查询的陷门构建方法，形成具有隐私保护的高效、准确几何范围查询方案，解决几何范围查询模式单一、加密算法安全性难以满足用户要求等难题。 2.3拟解决的关键科学问题（I）高效索引生成算法时空数据查询时位置数据的多维形式和隐私性给加密数据的外包计算带来巨大挑战。对于数据拥有者来说，安全高效的索引结构不仅有利于保护原始数据的安全性，合适的索引结构可以减少用户更新数据后修改索引的时间花销。对于查询数据用户来说，利于即时、准确地获取查询结果，并且可以提供“剪枝”帮助，减少对无用节点的访问，从而提高检索效率。支持加密时空数据的索引结构需要根据密文查询方案进行设计，使得在密文上可以进行相关度计算、搜索结果排序的同时不泄露相关度排序、访问模式等隐私信息。只采用布隆过滤器等传统索引生成方法无法保证快速获取查询结果，而时空数据特有的形式需要专门数据结构进行处理。因此，在用户隐私保护的基础上设计安全高效的时空数据索引结构是一个亟待解决的问题。（II）安全高效查询方案在实际应用场景下，针对时空数据的几何范围查询具有多样性，只支持单一几何范围查询（例如只支持矩形区域）无法达到高可用性的要求。此外，随着用户对隐私保护的重视逐渐增加，保序加密等安全性较弱方案无法做到对用户查询结果以及访问模式的保护[ Xu G, Li H, Dai Y, et al. Enabling efficient and geometric range query with access control over encrypted spatial data[J]. IEEE Transactions on Information Forensics and Security, 2018, 14(4): 870-885.]。因此，利用合适的加密算法构造安全高效且支持任意几何形状的时空数据查询方案尤为重要。 3、拟采取的研究方案及可行性分析。（一）支持隐私保护的高效几何范围查询方案本方案针对时空数据上的几何范围查询问题进行研究，主要研究支持隐私保护和高效搜索的索引构建算法及查询方案。针对文本搜索等领域的索引结构无法直接用到时空数据查询上的问题，本项目对传统搜索领域常用的索引生成算法及查询方案进行了改进，提出了高效安全的时空数据索引构建算法和查询方案。本方案系统模型中包括数据拥有者、数据使用者（查询用户），以及两个云服务提供商：S1、S2（假设不相互勾结）。所提方案研究思路如图X所示。在预处理阶段，先将时空数据按照距离关系构建R树，其中每个叶子节点都代表一个具体位置点，每个非叶子节点代表一个矩形区域。之后将所有时空数据加密后上传到云S1。对于索引的构建，方案首先将位置点坐标扩展为，然后利用可分布式解密公钥密码系统（PCDD）来生成加密索引，记为。为了提高搜索效率，同时也利用保序加密（OPE）对非叶子节点进行加密（记为），以便在查询阶段进行“剪枝”操作。针对实际应用场景下用户搜索范围多样导致搜索区间非标准几何图形的问题，本方案拟利用多项式拟合技术对范围进行“描述”。在用户对数据进行查询时，首先利用多项式拟合对搜索区域进行拟合，将多项式系数进行提取后利用PCDD进行加密，作为陷门的一部分。同样，为了使“剪枝”步骤可行，将此搜索区域的最小邻接矩形（minimum bounding rectangle, MBR）的左下角点和右上角点坐标进行保序加密，并由此生成完整的陷门。为了返回落入用户查询范围的位置点信息，本方案设计云S1在接收到用户查询陷门后运行查询方案，利用多域安全乘法协议（MSM）及可分布式解密公钥密码系统（PCDD）的性质对密文索引与陷门进行向量內积运算。期间，为了提高用户查询效率，云S1将对加密后的R树进行“剪枝”操作，以减少对无用节点的访问。同时，为了保障用户的隐私，云S1与云S2将进行交互，使得两方都无法从陷门函数、索引以及搜索结果中获取用户隐私信息。 4、本项目的特色与创新之处。本方案特色之处在于从构造具有隐私保护且支持任意几何范围的高效时空数据查询需求出发，将多项式拟合技术、多域安全乘法协议（MSM）、可分布式解密公钥密码系统（PCDD）等密码学进展与已有数据结构相结合，不仅实现了原有方案未能达到的隐私保护级别，还实现了对任意几何范围查询的支持。本项目的创新之处主要在于：针对具有隐私保护需求的任意几何范围时空数据查询，本方案提出了利用R树、可分布式解密公钥密码系统（PCDD）以及多域安全乘法协议（MSM）构建支持高效搜索的加密索引方案，将数据拥有者面临的隐私泄露问题降到最低。针对传统时空数据搜索方案支持单一图形、规则图形的缺陷，本方案利用多项式拟合技术对不规则查询范围进行拟合，巧妙设计索引内容，利用向量內积计算方法判断是否满足查询需求。]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2019%2F08%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[出于效率低下以及不认真的态度的问题，我大一下学期的数据结构与算法分析挂掉了。但我并不想只是应付补考。于是我打算用八个上午学习这个东西。我先说个规矩写的要求就是假如有一个人后来看到，他能获得知识 第一个上午数据结构的概念数据结构 数据结构是一门研究非数值计算的程序设计问题中的操作的对象，以及他们之间的关系和操作等相关问题的学科。数据结构是一种或多种特定关系的数据元素的集合。 数据 数据是描述客观事物的符号，是计算机中可操作的对象，是能被计算机识别，并识别给计算机处理的符号集合 数据元素 是组成数据有一定意义的基本单位，也称为记录例如人就是数据元素，而数据项就是眼睛耳朵 数据项 一个数据元素可由不同的数据项组成，数据项是数据不可分割的最小单位 但是在建立模型中还是把数据元素作为着眼点。 逻辑结构 平等的 集合结构 一对一 线性结构 一对多 树形结构 多对多 图形结构 储存结构 顺序储存结构 连续的储存单元 链式储存结构 元素放在任意的储存单元中，用一个指针存放数据元素的地址 总结：逻辑结构是面向问题的，而储存结构是面向计算机的。 抽象数据类型 这是指一个数学模型和定义在上面的一组操作体现了程序设计中问题分解，抽象和信息隐藏的特性。 这个现在不能理解，以后再回来写这个。 算法算法的特性 输入，输出，算法必须有零个或多个输入并且有一个或者多个输出。 有穷性 算法不能无限循环 确定性 算法每一个步骤都不会产生歧义 可行性 每一步但是能够通过有限次数实现的 算法设计的要求，以及我之后代码的写作自我要求正确性，对于特殊数据也有正确回应方便阅读，在看不懂的地方有注释效率高储存量低 算法的计算量for（i=1;i&lt;n;i++） { for(j=0;j&lt;=n;j++) { x++; sum=sum++; } } ptintf(&quot;%d,sum&quot;);这个程序执行了n*n次。 线性阶类似于上面的代码，直接看最高次项和他的系数如5n^2的复杂度就是o（n^2） 对数阶 类似于下面2^x=n。x=log2n,所以这个循环的复杂度就是o（logn） int count=1; while(count&lt;n) { count=count*2; } 常用时间复杂度从小到大依次是o(1)&lt;o(logn)&lt;o(n)&lt;o(nlogn)&lt;o(n^2)&lt;o(n^3)&lt;o(2^n)&lt;o(n!)&lt;o(n^n)当然算法还有最坏情况和平均复杂度。还有算法的空间复杂度，不重要在这里就不说了。 第二个上午线性表这个东西不知道浪费了我多少时间 关于定义零个或者多个数据元素的有限序列 ai有一个直接前驱和一个直接后继元素 线性表的顺序储存结构：用一段连续储存单元依次存储线性表的数据元素 线性表的抽象数据类型看不懂的东西又来啦 可以理解为数据结构中必须要进行把变量进行抽象数据类型。 List 线性表 顺序储存 #define MAXSIZE 20 /储存空间出事分配量/ typedef int Elemtype; typedef struct { Elemtype data[MAXSIZE]://数据储存数据元素的最大值 int length;//线性表的最大长度 }Sqlist; 以后还会有很多类似代码 typedef可以理解为规定一种形式类似于Elemtype被规定为int 而这个结构体被规定为Sqlist而在之中 data就是地址 顺序储存结构需要三个属性 储存空间的起始位置：我们可以理解为储存位置就是包含起始位置 线性表的最大存储容量 线性表的当前长度 位置考试可能会考 直接线性相加 线性储存结构的优缺点优点:无需为表明逻辑关系而添加额外的储存空间。可以快速存取任意位置的元素缺点：插入和删除需要移动大量元素。当线性表长度过大时无法确定长度。容易造成储存空间的碎片化。 status等同于typedef int status 取出（因为第一个元素位置是零所以要返回i-1） status GetList(Sqlist L,int i,Elentype *e) { if(L.length==0 || i&lt;1 || i&gt;L.length) return ERROR; *e=L.data[i-1]；//在这里说一下*e就直接可以返回地址上的数值 return OK； }插入 Status ListInsert(SqList *L，int i, Elemtype e) { int k; if(L-&gt;length==MAXSIZE) return ERROR； if(i&lt;1 || i&gt;L-&gt;length+1) return ERROR; if (i&lt;L-&gt;length) { for(k=L-&gt;length-1,k&gt;i-1,k--) L-&gt;data[k+1]=L-&gt;data[k]; } L-&gt;data[i-1]=e;//注意这里L-&gt;就是指向这个地址的数值 L-&gt;length++; return OK; }删除相似就不写了 线性表链式储存结构结点：数据域和指针域的同一个位置绑定起来统一叫做结点 链表中的第一个结点的储存位置叫头指针//这一上午实在是没干啥， 第三天接上面，最后一个结点不需要储存下一个位置，所以最后一个结点不需要储存位置，所以他的结点指针为空也可以是^。通常，为了方便我们通常设立一个头结点。数据域不储存数据 线性表的单链表储存结构 typedef struct Node { Elemtype data;//数据域 struct Node *next;//指针域 } Node; typedef struct Node *LinkList;//定义LinkList结点Node的结构由存放数据的数据域和存放后继地点指针的指针组成。 *假设p是指向第i个结点的指针那么ai的数据域就可以用p-&gt;data来表示，p-&gt;data的值是一个数据元素，此时ai的指针域便是p-&gt;next,p-&gt;next是一个指针默认指向i+1个元素 * 单链表的操作对于单链表的GetElem 获得链表的第一个数据较麻烦。 Status GetElem (LinkList L,int i,ElemType *e)//用e返回L中第i个数值。 { int j; LinkList p;//定义指针p p=L-&gt;next;//让p指向链表上头节点 j=1;//计数器 while(p &amp;&amp; j&lt;i)//因为结尾指针是空所以到指针空停止，还有到数停止。 { p=p-&gt;next ++j; } if(!p || j&gt;i) return ERROR; *e=p-&gt;data; return OK; }这个相比于顺序较难但插入和删除容易 Status GetInsert (LinkList L,int i,ElemType e)//L中第i个数值前加入数值e。 { int j; LinkList p,s;//定义指针p p=*L;//可以理解为变量p用于l储存地址 j=1; while(p &amp;&amp; j &lt; 1 ) { p-p-&gt;next; ++j; } if(!p || i&gt;j)//结点p不存在 return ERROR； s = (Linklist) malloc (sizeof (Node) );// 生成新结点 s-&gt;data=e; //以下是经典三步 s-&gt;next=p-&gt;next; p-&gt;next=s;![](https://i.imgur.com/GiqdXKk.jpg) return OK; }删除就一句p-&gt;next=p-&gt;next-&gt;nextq是要删除的结点 q=p-&gt;next; p-&gt;next=q-&gt;next; free(q); 整表创建 1234void CreateListHead(LinkList *L, int n )LinkList p;int i;*L= (LinkList)malloc(sizeof（Node）); 链表知识总结 如果要进行频繁查找要用顺序储存结构，而频繁进行插入删除就用链式。 当不知道到底有多少元素是一定要用链表。 多种链表静态链表用数组实现的链表 用下标来定义位置用两个数组 优缺点 优点 比较顺序直接改下标不用移动缺点 依然没解决储存空间的问题，失去了顺序表随机存取的特性 循环链表简而言之就是将单链表做成环 把尾指针做成rear rear-&gt;next-&gt;next,就可以了。 双向链表双向链表就是在每一个结点中在设置一个指向其前驱结点的指针域。 其体现 //定义结点时 typedef struct DulNode { Typedef data; struct DolNode *prior; struct DolNode *next; }DulNode,*DulLinkList;第四天我今天 栈stack栈的概念栈是一种只能在表尾进行操作的线性表。 允许插入和删除的一段被称为栈顶（top），另一端称为栈底（bottom), 栈是后进先出的思想 操作主要是进栈和出栈操作 栈的基本操作typedef int SElemType; typedef struct { SElemType data[MAXSIZE]&apos; int top; }SqStack;//结构定义 //进栈 Status Push（SqStack *S, SElemType e） { if(s-&gt;top == MAXSIZE -1) { return ERROR; } s-&gt;top++; s-&gt;data[s-&gt;top]=e; return OK; }可以两栈共享空间 栈的链式 typedef struct StackNode; { SElemType data; struct StackNode *next; }SqStackNode,*LinkstackPri;//这一步可以理解为构建头节点 typedef struct LinkStack { LinkstackPri top; int count; }LinkStack;//结构定义至于其他操作就记住把尾指针s-&gt;next=S-&gt;next 栈的使用如果数据可控最好还是用顺序栈 可以使用递归 递归的定义：把一个直接调用自己或通过一系列的调用语句间接的调用自己的函数，成为递归函数。 队列queue队列方面的定义队列是只允许一端进入，一端删除的线性表。 允许插入的叫队尾rear，允许删除的叫队头front 具体操作略过。 串string串是由零个或多个字符字符组成的有限序列，又叫字符串。 串的操作明天再说 吃了没有保存的亏那就重新来第五天 第五天树（tree） 根节点唯一 而且结点的子树数量是没有限制的。 但他们一定不相交 结点结点分为，根节点，内部节点，叶节点 节点之间的关系也可以分为父母，兄弟，孩子。 结点是有次序的，左子树和右子树不可以互换。 层次，很好理解，就是从根开始每有一个孩子就有一个层次。 最高层次树称为树的深度。 树的储存结构可以有双亲，孩子，双亲孩子兄弟，很灵活 至于代码实现很相似 typedef struct CSNode//构建结点 { TElemType data;//数据域 struct CSNode *firstchild,*rightsib//指针域 }CSNode,*CStree//结点，定义树这个结构二叉树特点 每个结点都有两个子树，所以结点的度不大于2 左右子树顺序不能颠倒 特殊二叉树斜二叉树 分为左二叉树，右二叉树 满二叉树 所有叶子都在同一度上，且所有内部结点都满度。 完全二叉树 所有结点的序号都和满二叉树相同。 二叉树性质 在第i层上最多只有2^（i-1）个结点。 深度为k最多有2^k-1个结点 在二叉树上叶子结点为n0，2度结点为n2，那么n0=n2+1 n个结点的完全二叉树深度log2(n)+1 完全二叉树结点一定是6.7.。。。。4.5.。。。。这种偶数在前的。 二叉树的储存结构按照层序可以直接存放于数组之中，如果不存在就直接用^来代替 顺序储存结构一般只用于完全二叉树 二叉链表 一般直接定义左孩子和右孩子。为指针域 二叉树的遍历画一个小重点，]]></content>
  </entry>
  <entry>
    <title><![CDATA[渲染的书写方式]]></title>
    <url>%2F2019%2F08%2F11%2F%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[在这里就把markdown写作格式写下来 #这个是一个大标题 ##这是一个小标题 ###这是小小标题正文这里是斜体 这里是粗体 #粗写的大标题粗写的大标题显然失败了 1printf &quot;Hello world&quot;; 这是代码的书写方式，注意要用tab键实现缩进代码 这两种方式都可以做出分割线 我是第一行 我是第二行用-或*就可以写出无顺序的分点要注意-和星后要有一个空格 有序的分点 第一点 第二点 第三点 据说这是引用格式，不过应该可以用在别的地方 注意中间要有一个空格 插入图片 有趣的灵魂万里挑一 朋友的bloglin \这个是转义字符如*这就不是斜体了* 快捷键 （看到这个才知道好像之前的都白看了） ctrl题 ctrl+2 二级标题 ctrl+u 无序列表+1 一级标ctrl+g 插入图片 ctrl+l 插入超链接 Ctrl+B 粗体 Ctrl+I 斜体 Ctrl+Q 引用 Ctrl+K 代码块 大标题算了以后还是用快捷键吧]]></content>
  </entry>
  <entry>
    <title><![CDATA[新开始]]></title>
    <url>%2F2019%2F08%2F10%2F%E6%96%B0%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[我愿乘风破浪 我打算开始对我的生活负起责任来,一个人总应该对自己的生活有着绝对的控制力。我不喜欢别人去窥探我的生活。因此我不会把这个blog告诉很多人，这是我的技术blog。我也会在将来把我的一些感想写到上面，写点东西总是好的，我在此承诺“我不会卖弄任何写到这里的东西。”因为卖弄本身就是一种浪费经历的方式。我在此承诺“我在这里写的东西，不为给任何人看而写。最后展望一下未来，我希望以我毕生的时间逐渐掌控自我，达到真正的自由。lll第一个认真和我说的导师告诉我优秀的这方面人就是要坚持，勤奋，不放l弃，不畏难。lllllllllllllllllllllllllllllllllllllllllllllllll 1现在是八月十四日，好像学了点什么其实又没干什么，在家里呆着衣食无忧还有朋友陪着。真是好舒服啊，不用面对不必要的关系，好像挺积极向上，但有些东西必须是应该自己去探寻。比如在离开朋友之后如何保持高校学习，如何避免堕落。人思想的转变在于交流，不同堕落的人交谈就可以不受他们的影响，不要忘了掌控自己。 2现在是八月十五日我决定进行重游泰康计划 标志地点 天湖渔场 十一楼 到四公里路上的心性树 小南屯的厂房 邪气的高层顶点 南湖 德力法尔工业园区 西湖小广场 航拍地点 在西湖小广场上转圈，晒太阳，拍曼妥思可乐 。德力法尔 拍日落 十一楼作为开始先去天湖渔场再去西湖，之后去看树，最后一次高层 南湖 小南屯打卡。最后去德力法尔拍日落。 虽然大多数没有打卡到，但是留下了很多回忆。详见火箭狂雷 3不要试图给别人看什么 4八月十六日 分析一下选课 第一轮为正式选 八月二十日九点开始 第一志愿推荐班级一定会入选，剩余抽签来选。 5现在是八月二十五日 想一下去年为什么在图书馆效率那么低，你想一下继续效率低迷还能持续像现在这样大量的工作吗，问你明天就开学了，一天自习七小时难道还要溜号六小时？累了就歇一会，不要看手机。]]></content>
  </entry>
</search>
